<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed &mdash; Self-driving, multi-scale image analysis 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Self-driving, multi-scale image analysis
              <img src="../../../../_static/multi_scale_analysis_logo.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started and installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Installation.html">Getting started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Microscope characterization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../PSF_analysis.html">PSF analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ShannonEntropyAnalysis.html">Shannon Entropy Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Low-resolution analysis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Data_stitching.html">Data stitching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../LowRes_Segmentation.html">Low-resolution segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../HopkinsStatistics.html">Hopkins Statistics Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">High-resolution analysis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../HighRes_Segmentation.html">High-resolution segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Cell_ShapeAnalysis.html">Cell Shape Feature Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Cell_CurvatureAnalysis.html">Cell Curvature Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Data_visualization.html">Data visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python references</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">multiScaleAnalysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Self-driving, multi-scale image analysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Mon Feb 20 22:35:23 2023</span>

<span class="sd">@author: fyz11</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_mkdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">os</span> 
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">_normalize99</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">lower</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">upper</span><span class="o">=</span><span class="mf">99.99</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; normalize image so 0.0 is 0.01st percentile and 1.0 is 99.99th percentile </span>
<span class="sd">    Upper and lower percentile ranges configurable. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Y: ndarray, float</span>
<span class="sd">        Component array of lenth N by L1 by L2 by ... by LN. </span>
<span class="sd">    upper: float</span>
<span class="sd">        upper percentile above which pixels are sent to 1.0</span>
<span class="sd">    </span>
<span class="sd">    lower: float</span>
<span class="sd">        lower percentile below which pixels are sent to 0.0</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    --------------</span>
<span class="sd">    normalized array with a minimum of 0 and maximum of 1</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    
    <span class="n">X</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lower</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">upper</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_interp2</span><span class="p">(</span><span class="n">query_pts</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">I_ref</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">RegularGridInterpolator</span> 
    
    <span class="n">spl</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> 
                                   <span class="n">I_ref</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I_query</span> <span class="o">=</span> <span class="n">spl</span><span class="p">((</span><span class="n">query_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                   <span class="n">query_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">cast_uint8</span><span class="p">:</span>
        <span class="n">I_query</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">I_query</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">I_query</span>
    
<span class="k">def</span> <span class="nf">_interp3</span><span class="p">(</span><span class="n">query_pts</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">I_ref</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">RegularGridInterpolator</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">spl_3</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                         <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> 
                                         <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span> 
                                         <span class="n">I_ref</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">I_query</span> <span class="o">=</span> <span class="n">spl_3</span><span class="p">((</span><span class="n">query_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                      <span class="n">query_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">query_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">cast_uint8</span><span class="p">:</span>
        <span class="n">I_query</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">I_query</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">I_query</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># 2D stuff </span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="connected_components_pts_2D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.connected_components_pts_2D">[docs]</a>
<span class="k">def</span> <span class="nf">connected_components_pts_2D</span><span class="p">(</span> <span class="n">pts</span><span class="p">,</span> <span class="n">pts0</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> 
                                <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">thresh_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">min_area</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> 

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span>
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span> 
    
    <span class="c1"># parse ... </span>
    <span class="n">votes_grid_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># count</span>
    <span class="n">votes_grid_acc</span><span class="p">[(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                   <span class="p">(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="c1"># add a vote. </span>
                   
    <span class="c1"># smooth to get a density (fast KDE estimation)</span>
    <span class="n">votes_grid_acc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">)</span>  
    
    <span class="k">if</span> <span class="n">thresh_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">votes_grid_binary</span> <span class="o">=</span> <span class="n">votes_grid_acc</span> <span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">+</span> <span class="n">thresh_factor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">votes_grid_binary</span> <span class="o">=</span> <span class="n">votes_grid_acc</span> <span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">)</span> <span class="o">+</span> <span class="n">thresh_factor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">votes_grid_binary</span> <span class="o">=</span> <span class="n">votes_grid_acc</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">)</span> <span class="c1"># just threshold over the mean. </span>
        
    <span class="n">cell_seg_connected</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">votes_grid_binary</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># use the full conditional </span>
    <span class="n">cell_uniq_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_seg_connected</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_uniq_regions</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">cell_seg_connected</span><span class="p">)</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">re</span> <span class="ow">in</span> <span class="n">props</span><span class="p">])</span>
        <span class="n">invalid_areas</span> <span class="o">=</span> <span class="n">cell_uniq_regions</span><span class="p">[</span><span class="n">areas</span><span class="o">&lt;=</span><span class="n">min_area</span><span class="p">]</span>
    
        <span class="k">for</span> <span class="n">invalid</span> <span class="ow">in</span> <span class="n">invalid_areas</span><span class="p">:</span>
            <span class="n">cell_seg_connected</span><span class="p">[</span><span class="n">cell_seg_connected</span><span class="o">==</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">if</span> <span class="n">cell_seg_connected</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cell_seg_connected</span> <span class="o">=</span> <span class="n">sksegmentation</span><span class="o">.</span><span class="n">relabel_sequential</span><span class="p">(</span><span class="n">cell_seg_connected</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    
    <span class="n">cell_seg_connected_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cell_seg_connected</span><span class="p">)</span>
    <span class="n">cell_seg_connected_original</span><span class="p">[(</span><span class="n">pts0</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                                <span class="p">(</span><span class="n">pts0</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cell_seg_connected</span><span class="p">[(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                                                                                 <span class="p">(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_seg_connected</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cell_seg_connected_original</span><span class="p">[</span><span class="n">mask</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># also mask the predicted. </span>

    <span class="k">return</span> <span class="n">cell_seg_connected_original</span><span class="p">,</span> <span class="n">cell_seg_connected</span><span class="p">,</span> <span class="n">votes_grid_acc</span> <span class="c1"># return the accumulator.!    </span></div>



<div class="viewcode-block" id="connected_components_pts_3D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.connected_components_pts_3D">[docs]</a>
<span class="k">def</span> <span class="nf">connected_components_pts_3D</span><span class="p">(</span> <span class="n">pts</span><span class="p">,</span> <span class="n">pts0</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> 
                                <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">thresh_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">min_area</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> 

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span>
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span> 
    <span class="c1">#import cc3d</span>
    
    <span class="c1"># parse ... </span>
    <span class="n">votes_grid_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># count</span>
    <span class="n">votes_grid_acc</span><span class="p">[(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                   <span class="p">(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="c1"># add a vote. </span>
                   
    <span class="c1"># smooth to get a density (fast KDE estimation)</span>
    <span class="n">votes_grid_acc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">)</span>  
    
    <span class="k">if</span> <span class="n">thresh_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">votes_grid_binary</span> <span class="o">=</span> <span class="n">votes_grid_acc</span> <span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">+</span> <span class="n">thresh_factor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">votes_grid_binary</span> <span class="o">=</span> <span class="n">votes_grid_acc</span> <span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">)</span> <span class="o">+</span> <span class="n">thresh_factor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">votes_grid_binary</span> <span class="o">=</span> <span class="n">votes_grid_acc</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">votes_grid_acc</span><span class="p">)</span> <span class="c1"># just threshold over the mean. </span>
        
    <span class="n">cell_seg_connected</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">votes_grid_binary</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># use the full conditional</span>
    <span class="c1">#cell_seg_connected = cc3d.connected_components(votes_grid_binary)</span>
    
    <span class="c1"># # we don&#39;t need this bit. </span>
    <span class="c1"># cell_uniq_regions = np.setdiff1d(np.unique(cell_seg_connected),0)</span>
    <span class="c1"># if len(cell_uniq_regions)&gt;0:</span>
    <span class="c1">#     props = skmeasure.regionprops(cell_seg_connected)</span>
    <span class="c1">#     areas = np.hstack([re.area for re in props])</span>
    <span class="c1">#     invalid_areas = cell_uniq_regions[areas&lt;=min_area]</span>
    
    <span class="c1">#     for invalid in invalid_areas:</span>
    <span class="c1">#         cell_seg_connected[cell_seg_connected==invalid] = 0</span>
        
    <span class="c1"># if cell_seg_connected.max() &gt; 0:</span>
    <span class="c1">#     cell_seg_connected = sksegmentation.relabel_sequential(cell_seg_connected)[0]</span>
    
    <span class="n">cell_seg_connected_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cell_seg_connected</span><span class="p">)</span>
    <span class="n">cell_seg_connected_original</span><span class="p">[(</span><span class="n">pts0</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                                <span class="p">(</span><span class="n">pts0</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                                <span class="p">(</span><span class="n">pts0</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cell_seg_connected</span><span class="p">[(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                                                                                 <span class="p">(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                                                                                 <span class="p">(</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_seg_connected</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cell_seg_connected_original</span><span class="p">[</span><span class="n">mask</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># also mask the predicted. </span>

    <span class="k">return</span> <span class="n">cell_seg_connected_original</span><span class="p">,</span> <span class="n">cell_seg_connected</span><span class="p">,</span> <span class="n">votes_grid_acc</span> <span class="c1"># return the accumulator.!    </span></div>



<span class="k">def</span> <span class="nf">_sdf_distance_transform</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">rev_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">distance_transform_edt</span>
    <span class="c1"># import skfmm</span>
    <span class="c1"># import GeodisTK</span>
    
    <span class="n">pos_binary</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">neg_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">pos_binary</span><span class="p">)</span>
    
    <span class="n">res</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">neg_binary</span><span class="p">)</span> <span class="o">*</span> <span class="n">neg_binary</span> <span class="o">-</span> <span class="p">(</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">pos_binary</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pos_binary</span>
    <span class="c1"># res = skfmm.distance(neg_binary, dx=0.5) * neg_binary - (skfmm.distance(pos_binary, dx=0.5) - 1) * pos_binary</span>
    <span class="c1"># res = skfmm.distance(neg_binary) * neg_binary - (skfmm.distance(pos_binary) - 1) * pos_binary # this was fast!. </span>
    <span class="c1"># res = geodesic_distance_2d((neg_binary*1.).astype(np.float32), S=neg_binary, lamb=0.8, iter=10) * neg_binary - (geodesic_distance_2d((pos_binary*1.).astype(np.float32), S=neg_binary, lamb=0.5, iter=10) - 1) * pos_binary</span>
    
    <span class="k">if</span> <span class="n">rev_sign</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">res</span>



<div class="viewcode-block" id="surf_normal_sdf">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.surf_normal_sdf">[docs]</a>
<span class="k">def</span> <span class="nf">surf_normal_sdf</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_gradient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">norm_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>

    <span class="n">sdf_vol</span> <span class="o">=</span> <span class="n">_sdf_distance_transform</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">rev_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># so that we have it pointing outwards!. </span>
    
    <span class="c1"># compute surface normal of the signed distance function. </span>
    <span class="n">sdf_vol_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">sdf_vol</span><span class="p">))</span>
    <span class="c1"># smooth gradient</span>
    <span class="k">if</span> <span class="n">smooth_gradient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># smoothing needs to be done before normalization of magnitude. </span>
        <span class="n">sdf_vol_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth_gradient</span><span class="p">)</span> <span class="k">for</span> <span class="n">sdf</span> <span class="ow">in</span> <span class="n">sdf_vol_normal</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">norm_vectors</span><span class="p">:</span>
        <span class="n">sdf_vol_normal</span> <span class="o">=</span> <span class="n">sdf_vol_normal</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sdf_vol_normal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sdf_vol_normal</span><span class="p">,</span> <span class="n">sdf_vol</span></div>



<div class="viewcode-block" id="mean_curvature_sdf">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.mean_curvature_sdf">[docs]</a>
<span class="k">def</span> <span class="nf">mean_curvature_sdf</span><span class="p">(</span><span class="n">sdf_normal</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">divergence</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the divergence of the vector field f, corresponding to dFx/dx + dFy/dy + ...</span>
<span class="sd">        :param f: List of ndarrays, where every item of the list is one dimension of the vector field</span>
<span class="sd">        :return: Single ndarray of the same shape as each of the items in f, which corresponds to a scalar field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_dims</span><span class="p">)])</span>
        
    <span class="n">H</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">divergence</span><span class="p">(</span><span class="n">sdf_normal</span><span class="p">))</span><span class="c1"># total curvature is the divergence of the normal. </span>
    
    <span class="k">return</span> <span class="n">H</span> </div>



<div class="viewcode-block" id="gradient_watershed2D_binary">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.gradient_watershed2D_binary">[docs]</a>
<span class="k">def</span> <span class="nf">gradient_watershed2D_binary</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> 
                                <span class="n">gradient_img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">divergence_rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">smooth_gradient</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">delta</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> 
                                <span class="n">n_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                                <span class="n">min_area</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                                <span class="n">eps</span><span class="o">=</span><span class="mf">1e-20</span><span class="p">,</span> 
                                <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">thresh_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">track_flow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1"># if track_flow then we record!. </span>
                                <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">debug_viz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; parses the instance level segmentation implicitly given as an input binary or a vector field. </span>
<span class="sd">    The algorithm works as an inverse watershed.</span>
<span class="sd">    </span>
<span class="sd">    Step 1: a grid of points is seeds on the image</span>
<span class="sd">    Step 2: points are propagated for n_iter according to the gradient_img, condensing towards cell centers implicitly implied by the gradient image.</span>
<span class="sd">    Step 3: individual cluster centers are found by binarisation and connected component, removing objects &lt; min_area</span>
<span class="sd">    </span>
<span class="sd">    result is an integer image the same size as binary. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binary : (MxNxL) numpy array</span>
<span class="sd">        input binary image defining the voxels that need labeling</span>
<span class="sd">    gradient_img :  (MxNxLx3) numpy array</span>
<span class="sd">        This is a gradient field such as that from applying np.array(np.gradient(img)).transpose(1,2,3,0) where img is a potential such as a distance transform or probability map. </span>
<span class="sd">    divergence_rescale : </span>
<span class="sd">        If True, the gradient_img is scaled by the divergence which is equivalent to the mean curvature, this helps to prevent early breakage for tube-like structures.   </span>
<span class="sd">    smooth_sigma : scalar</span>
<span class="sd">        controls the catchment area for identifying distinct cells at the final propagation position. Smaller smooth_sigma leads to more oversegmentation. </span>
<span class="sd">    smooth_gradient : scalar</span>
<span class="sd">        the isotropic sigma value controlling the Gaussian smoothing of the gradient field. More smoothing results in more cells grouped together</span>
<span class="sd">    delta: scalar</span>
<span class="sd">        the voxel size to propagate grid points per iteration. Related to the stability. If too small takes too long. If too large, might not converge. if delta=1, takes a 1 voxel step. </span>
<span class="sd">    n_iter: int </span>
<span class="sd">        the number of iterations to run. (To do: monitor convergence and break early to improve speed)</span>
<span class="sd">    min_area: scalar</span>
<span class="sd">        volume of cells &lt; min_area are removed. </span>
<span class="sd">    eps: float</span>
<span class="sd">        a small number for numerical stability</span>
<span class="sd">    thresh_factor: scalar</span>
<span class="sd">        The final cells are identified by thresholding on a threshold mean+thresh_factor*std. Thresh_factor controls what is an object prior to connected components analysis </span>
<span class="sd">    mask: (MxNxL) numpy array</span>
<span class="sd">        optional binary mask to gate the region to parse labels for.</span>
<span class="sd">    debug_viz: bool</span>
<span class="sd">        if True, visualise the position of the points at every algorithm iteration. </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cell_seg_connected_original : (MxNxL)</span>
<span class="sd">        an integer image where each unique int &gt; 0 relates to a unique object such that object 1 is retrieved by cell_seg_connected_original==1.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span> 
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span> 
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    
    <span class="c1"># compute the signed distance transform</span>
    <span class="k">if</span> <span class="n">gradient_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">gradient_img</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># use the supplied gradients! </span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">binary</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sdf_normals</span><span class="p">,</span> <span class="n">sdf_binary</span> <span class="o">=</span> <span class="n">surf_normal_sdf</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_gradient</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">norm_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">binary</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">divergence_rescale</span><span class="p">:</span>
        <span class="c1"># rescale the speed</span>
        <span class="n">curvature_2D</span> <span class="o">=</span> <span class="n">mean_curvature_sdf</span><span class="p">(</span><span class="n">sdf_normals</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sdf_normals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">+</span><span class="n">eps</span><span class="p">))</span>
        <span class="n">curvature_2D</span> <span class="o">=</span> <span class="n">_normalize99</span><span class="p">(</span><span class="n">curvature_2D</span><span class="p">)</span> <span class="c1"># rescales to a factor between 0-1</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">curvature_2D</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1"># multiplicative factor rescaling </span>
        
        
    <span class="c1"># print(sdf_normals.shape)</span>
    <span class="n">grid</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">binary</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># (N,ndim)</span>
    
    <span class="n">tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">pts</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)):</span>
        <span class="n">pt_ii</span> <span class="o">=</span> <span class="n">tracks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">interp</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_interp2</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">sdf_normals</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sdf_normals</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">sdf_normals</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
        
        <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">pts_vect_ii</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts_vect_ii</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">pt_ii_next</span> <span class="o">=</span> <span class="n">pt_ii</span> <span class="o">+</span> <span class="n">delta</span><span class="o">*</span><span class="n">pts_vect_ii</span>
            
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">track_flow</span><span class="p">:</span>
            <span class="n">tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tracks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt_ii_next</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># copy over. </span>
        
        <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;r.&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="n">tracks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tracks</span><span class="p">)</span>
    
    <span class="n">cell_seg_connected_original</span><span class="p">,</span> <span class="n">cell_seg_connected</span><span class="p">,</span> <span class="n">votes_grid_acc</span> <span class="o">=</span> <span class="n">connected_components_pts_2D</span><span class="p">(</span> <span class="n">pts</span><span class="o">=</span><span class="n">tracks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                                                                                    <span class="n">pts0</span><span class="o">=</span><span class="n">pts</span><span class="p">,</span> 
                                                                                                    <span class="n">shape</span><span class="o">=</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> 
                                                                                                    <span class="n">smooth_sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">,</span> 
                                                                                                    <span class="n">thresh_factor</span><span class="o">=</span><span class="n">thresh_factor</span><span class="p">,</span> 
                                                                                                    <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                                                                                    <span class="n">min_area</span><span class="o">=</span><span class="n">min_area</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cell_seg_connected_original</span><span class="p">,</span> <span class="n">cell_seg_connected</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">votes_grid_acc</span></div>



<span class="c1"># can we make this v. fast? ---&gt; it is mainly the advection that is slow....., if we could parallelize in blocks? </span>
<div class="viewcode-block" id="gradient_watershed3D_binary">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.gradient_watershed3D_binary">[docs]</a>
<span class="k">def</span> <span class="nf">gradient_watershed3D_binary</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> 
                                <span class="n">gradient_img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">momenta</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
                                <span class="n">divergence_rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">smooth_gradient</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">n_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">min_area</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                                <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> 
                                <span class="n">thresh_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">use_connectivity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                <span class="n">connectivity_alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                                <span class="n">debug_viz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">renorm_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; parses the instance level segmentation implicitly given as an input binary or a vector field. </span>
<span class="sd">    The algorithm works as an inverse watershed.</span>
<span class="sd">    </span>
<span class="sd">    Step 1: a grid of points is seeds on the image</span>
<span class="sd">    Step 2: points are propagated for n_iter according to the gradient_img, condensing towards cell centers implicitly implied by the gradient image.</span>
<span class="sd">    Step 3: individual cluster centers are found by binarisation and connected component, removing objects &lt; min_area</span>
<span class="sd">    </span>
<span class="sd">    result is an integer image the same size as binary. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binary : (MxNxL) numpy array</span>
<span class="sd">        input binary image defining the voxels that need labeling</span>
<span class="sd">  	gradient_img :  (MxNxLx3) numpy array</span>
<span class="sd">        This is a gradient field such as that from applying np.array(np.gradient(img)).transpose(1,2,3,0) where img is a potential such as a distance transform or probability map. </span>
<span class="sd">    divergence_rescale : </span>
<span class="sd">        If True, the gradient_img is scaled by the divergence which is equivalent to the mean curvature, this helps to prevent early breakage for tube-like structures.   </span>
<span class="sd">    smooth_sigma : scalar</span>
<span class="sd">        controls the catchment area for identifying distinct cells at the final propagation position. Smaller smooth_sigma leads to more oversegmentation. </span>
<span class="sd">    smooth_gradient : scalar</span>
<span class="sd">    	the isotropic sigma value controlling the Gaussian smoothing of the gradient field. More smoothing results in more cells grouped together</span>
<span class="sd">    delta: scalar</span>
<span class="sd">    	the voxel size to propagate grid points per iteration. Related to the stability. If too small takes too long. If too large, might not converge. if delta=1, takes a 1 voxel step. </span>
<span class="sd">    n_iter: int </span>
<span class="sd">        the number of iterations to run. (To do: monitor convergence and break early to improve speed)</span>
<span class="sd">    min_area: scalar</span>
<span class="sd">        volume of cells &lt; min_area are removed. </span>
<span class="sd">    eps: float</span>
<span class="sd">        a small number for numerical stability</span>
<span class="sd">    thresh_factor: scalar</span>
<span class="sd">        The final cells are identified by thresholding on a threshold mean+thresh_factor*std. Thresh_factor controls what is an object prior to connected components analysis </span>
<span class="sd">    mask: (MxNxL) numpy array</span>
<span class="sd">        optional binary mask to gate the region to parse labels for.</span>
<span class="sd">    debug_viz: bool</span>
<span class="sd">        if True, visualise the position of the points at every algorithm iteration. </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cell_seg_connected_original : (MxNxL)</span>
<span class="sd">        an integer image where each unique int &gt; 0 relates to a unique object such that object 1 is retrieved by cell_seg_connected_original==1.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span> 
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span> 
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="kn">from</span> <span class="nn">.plotting</span> <span class="kn">import</span> <span class="n">set_axes_equal</span>
    
    <span class="k">if</span> <span class="n">gradient_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">gradient_img</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># use the supplied gradients! </span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">binary</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># compute the signed distance transform</span>
        <span class="n">sdf_normals</span><span class="p">,</span> <span class="n">sdf_binary</span> <span class="o">=</span> <span class="n">surf_normal_sdf</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_gradient</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">norm_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">binary</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">use_connectivity</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.feature_extraction.image</span> <span class="kn">import</span> <span class="n">grid_to_graph</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span> 
        
        <span class="n">W</span> <span class="o">=</span> <span class="n">grid_to_graph</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                        <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                        <span class="n">mask</span><span class="o">=</span><span class="n">binary</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># convert this to laplacian.   </span>
    
        <span class="c1"># create the averaging matrix </span>
        <span class="n">DD</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">DD</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">W</span> <span class="o">=</span> <span class="n">DD</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># averaging</span>
        <span class="k">del</span> <span class="n">DD</span> <span class="c1"># some memory management. </span>
        
        <span class="n">alpha</span><span class="o">=</span><span class="n">connectivity_alpha</span>
        
    <span class="k">if</span> <span class="n">divergence_rescale</span><span class="p">:</span>
        <span class="c1"># rescale the speed</span>
        <span class="n">curvature_3D</span> <span class="o">=</span> <span class="n">mean_curvature_sdf</span><span class="p">(</span><span class="n">sdf_normals</span><span class="p">)</span>
        <span class="n">curvature_3D</span> <span class="o">=</span> <span class="n">_normalize99</span><span class="p">(</span><span class="n">curvature_3D</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">upper</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span> <span class="c1"># rescales to a factor between 0-1</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">curvature_3D</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1"># multiplicative factor rescaling </span>
    
    <span class="c1"># grid =  np.zeros(binary.shape, dtype=np.int32)</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">binary</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># (N,ndim)</span>
    <span class="c1"># pt_ii = np.argwhere(binary&gt;0).astype(np.float32)</span>
    <span class="n">pt_ii</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># tracks = [pts]</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">momenta</span> <span class="c1"># momentum</span>
    <span class="c1"># g0 = np.zeros(pts.shape)</span>
    <span class="n">g0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">)</span>
    
    <span class="c1"># delta_position_changes = []</span>
    
    <span class="c1"># if use_connectivity:</span>
    <span class="c1">#     import point_cloud_utils as pcu </span>
    <span class="c1">#     _, W = pcu.k_nearest_neighbors(pts, pts, k=5)</span>
    <span class="c1">#     alpha=connectivity_alpha</span>
    
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)):</span>
        <span class="c1"># pt_ii = tracks[-1].copy()</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        interp helps!. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interp</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_interp3</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">sdf_normals</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sdf_normals</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&#39;no interp&#39;)</span>
            <span class="c1"># pts_vect_ii = sdf_normals[:,</span>
            <span class="c1">#                           pt_ii[...,0].astype(np.int32), </span>
            <span class="c1">#                           pt_ii[...,1].astype(np.int32), </span>
            <span class="c1">#                           pt_ii[...,2].astype(np.int32)].T  # direct lookup - not interp!. </span>
            <span class="c1"># faster index with flat indices? </span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf_normals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">pt_ii</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sdf_normals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
            
            
        <span class="c1"># renormalize</span>
        <span class="k">if</span> <span class="n">renorm_gradient</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">pts_vect_ii</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts_vect_ii</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
            <span class="c1"># pts_vect_ii = pts_vect_ii / (np.sqrt(np.sum(pts_vect_ii**2, axis=-1))[:,None] + 1e-20)</span>
<span class="w">            </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update step:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_connectivity</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">pts_vect_ii</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pts_vect_ii</span><span class="p">)</span> <span class="c1"># twice</span>
            <span class="c1"># pts_vect_ii = alpha * pts_vect_ii + (1-alpha) * np.nanmean(pts_vect_ii[W], axis=1)</span>
            
        <span class="c1"># else:</span>
        <span class="c1"># pt_ii_next = pt_ii + delta*pts_vect_ii</span>
        <span class="n">pt_ii_next</span> <span class="o">=</span> <span class="n">pt_ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span><span class="o">*</span><span class="n">pts_vect_ii</span> <span class="o">+</span> <span class="n">mu</span><span class="o">*</span><span class="n">g0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">delta</span><span class="o">+</span><span class="n">mu</span><span class="p">))</span>  <span class="c1"># add momentum + connectivity. </span>
        <span class="n">g0</span> <span class="o">=</span> <span class="n">pts_vect_ii</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># copy this into the past history.... </span>
        
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># delta_change = np.nanmean(np.linalg.norm(pt_ii_next-pt_ii, axis=-1)) # mean or median?  # this can help with early stopping!. </span>
        <span class="c1"># delta_position_changes.append(delta_change)</span>
        <span class="c1"># print(delta_change)</span>
        
        <span class="c1"># tracks[-1] = pt_ii_next # overwrite </span>
        <span class="n">pt_ii</span> <span class="o">=</span> <span class="n">pt_ii_next</span>
        
        <span class="c1"># plt.figure(figsize=(10,10))</span>
        <span class="c1"># plt.imshow(binary.max(axis=0))</span>
        <span class="c1"># plt.plot(pt_ii_next[:,2], </span>
        <span class="c1">#          pt_ii_next[:,1], &#39;r.&#39;)</span>
        <span class="c1"># plt.show()</span>
        
        <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_proj_type</span><span class="p">(</span><span class="s1">&#39;ortho&#39;</span><span class="p">)</span> <span class="c1"># this works better!.</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_box_aspect</span><span class="p">(</span><span class="n">aspect</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># this works. </span>
            <span class="c1"># ax.scatter(v_watertight[::sampling,0], </span>
            <span class="c1">#             v_watertight[::sampling,1], </span>
            <span class="c1">#             v_watertight[::sampling,2], </span>
            <span class="c1">#             c=&#39;k&#39;, s=1, alpha=0.0)#all_labels_branches[np.squeeze(all_dists)&lt;20], s=1)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[::</span><span class="n">sampling</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                       <span class="n">pt_ii_next</span><span class="p">[::</span><span class="n">sampling</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                       <span class="n">pt_ii_next</span><span class="p">[::</span><span class="n">sampling</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ax.scatter(centroids3D_from_xz[:,0], </span>
            <span class="c1">#            centroids3D_from_xz[:,1],</span>
            <span class="c1">#            centroids3D_from_xz[:,2], c=&#39;g&#39;,s=10)</span>
            <span class="c1"># ax.scatter(centroids3D_from_yz[:,0], </span>
            <span class="c1">#            centroids3D_from_yz[:,1],</span>
            <span class="c1">#            centroids3D_from_yz[:,2], c=&#39;b&#39;,s=10)</span>
            <span class="c1"># # ax.scatter(skel3D_coords[:,0], </span>
            <span class="c1"># #             skel3D_coords[:,1],</span>
            <span class="c1"># #             skel3D_coords[:,2], c=&#39;k&#39;,s=5, alpha=1)</span>
            <span class="c1"># ax.view_init(-90,0)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">180</span><span class="p">)</span>
            <span class="c1"># ax.view_init(180,0)</span>
            <span class="c1"># ax.set_xlim([0,binary.shape[0]]) # why is this plot not good? </span>
            <span class="c1"># ax.set_ylim([0,binary.shape[1]])</span>
            <span class="c1"># ax.set_zlim([0,binary.shape[2]])</span>
            <span class="n">set_axes_equal</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        
<span class="c1"># =============================================================================</span>
<span class="c1">#     To DO: how can we utilise adaptive stopping? e.g. updating just a fraction of the points. ?     </span>
<span class="c1"># =============================================================================</span>
        
    <span class="c1"># # tracks = np.array(tracks)</span>
    <span class="c1"># # tracks = pt_ii</span>
    
    <span class="c1"># # parse ... </span>
    <span class="c1"># votes_grid_acc = np.zeros(binary.shape)</span>
    <span class="c1"># # votes_grid_acc[(tracks[-1][:,0]).astype(np.int32), </span>
    <span class="c1"># #                (tracks[-1][:,1]).astype(np.int32),</span>
    <span class="c1"># #                (tracks[-1][:,2]).astype(np.int32)] += 1. # add a vote. </span>
    <span class="c1"># votes_grid_acc[(pt_ii[:,0]).astype(np.int32), </span>
    <span class="c1">#                (pt_ii[:,1]).astype(np.int32),</span>
    <span class="c1">#                (pt_ii[:,2]).astype(np.int32)] += 1. # add a vote. </span>
                   
    <span class="c1"># # smooth to get a density (fast KDE estimation)</span>
    <span class="c1"># votes_grid_acc = ndimage.gaussian_filter(votes_grid_acc, sigma=smooth_sigma)   # gaussian or uniform? </span>
    
    <span class="c1"># if thresh_factor is not None:</span>
    <span class="c1">#     if mask is not None:</span>
    <span class="c1">#         votes_grid_binary = votes_grid_acc &gt;np.mean(votes_grid_acc[mask]) + thresh_factor*np.std(votes_grid_acc[mask])</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         votes_grid_binary = votes_grid_acc &gt;np.mean(votes_grid_acc) + thresh_factor*np.std(votes_grid_acc)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     votes_grid_binary = votes_grid_acc &gt; np.mean(votes_grid_acc) # just threshold over the mean. </span>
        
    <span class="c1"># cell_seg_connected = skmeasure.label(votes_grid_binary, connectivity=2)</span>
    <span class="c1"># cell_uniq_regions = np.setdiff1d(np.unique(cell_seg_connected),0)</span>
    <span class="c1"># if len(cell_uniq_regions)&gt;0:</span>
    <span class="c1">#     props = skmeasure.regionprops(cell_seg_connected)</span>
    <span class="c1">#     areas = np.hstack([re.area for re in props])</span>
    <span class="c1">#     invalid_areas = cell_uniq_regions[areas&lt;=min_area]</span>
    
    <span class="c1">#     for invalid in invalid_areas:</span>
    <span class="c1">#         cell_seg_connected[cell_seg_connected==invalid] = 0</span>
        
    <span class="c1"># if cell_seg_connected.max() &gt; 0:</span>
    <span class="c1">#     cell_seg_connected = sksegmentation.relabel_sequential(cell_seg_connected)[0]</span>
    
    
    <span class="c1"># cell_seg_connected_original = np.zeros_like(cell_seg_connected)</span>
    <span class="c1"># # cell_seg_connected_original[(pts[:,0]).astype(np.int32), </span>
    <span class="c1"># #                             (pts[:,1]).astype(np.int32),</span>
    <span class="c1"># #                             (pts[:,2]).astype(np.int32)] = cell_seg_connected[(tracks[-1][:,0]).astype(np.int32), </span>
    <span class="c1"># #                                                                               (tracks[-1][:,1]).astype(np.int32),</span>
    <span class="c1"># #                                                                               (tracks[-1][:,2]).astype(np.int32)]                                  </span>
    <span class="c1"># cell_seg_connected_original[(pts[:,0]).astype(np.int32), </span>
    <span class="c1">#                             (pts[:,1]).astype(np.int32),</span>
    <span class="c1">#                             (pts[:,2]).astype(np.int32)] = cell_seg_connected[(pt_ii[:,0]).astype(np.int32), </span>
    <span class="c1">#                                                                               (pt_ii[:,1]).astype(np.int32),</span>
    <span class="c1">#                                                                               (pt_ii[:,2]).astype(np.int32)]                                  </span>
    
    <span class="c1"># cell_seg_connected_original, cell_seg_connected, votes_grid_acc = connected_components_pts_3D( pts=tracks[-1], </span>
    <span class="c1">#                                                                                                 pts0=pts, </span>
    <span class="c1">#                                                                                                 shape=binary.shape[:3], </span>
    <span class="c1">#                                                                                                 smooth_sigma=smooth_sigma, </span>
    <span class="c1">#                                                                                                 thresh_factor=thresh_factor, </span>
    <span class="c1">#                                                                                                 mask=mask,</span>
    <span class="c1">#                                                                                                 min_area=min_area)</span>
    <span class="n">cell_seg_connected_original</span><span class="p">,</span> <span class="n">cell_seg_connected</span><span class="p">,</span> <span class="n">votes_grid_acc</span> <span class="o">=</span> <span class="n">connected_components_pts_3D</span><span class="p">(</span> <span class="n">pts</span><span class="o">=</span><span class="n">pt_ii</span><span class="p">,</span> 
                                                                                                    <span class="n">pts0</span><span class="o">=</span><span class="n">pts</span><span class="p">,</span> 
                                                                                                    <span class="n">shape</span><span class="o">=</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> 
                                                                                                    <span class="n">smooth_sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">,</span> 
                                                                                                    <span class="n">thresh_factor</span><span class="o">=</span><span class="n">thresh_factor</span><span class="p">,</span> 
                                                                                                    <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                                                                                    <span class="n">min_area</span><span class="o">=</span><span class="n">min_area</span><span class="p">)</span>
    
    <span class="c1"># return cell_seg_connected_original, cell_seg_connected, tracks, votes_grid_acc</span>
    <span class="k">return</span> <span class="n">cell_seg_connected_original</span><span class="p">,</span> <span class="n">cell_seg_connected</span><span class="p">,</span> <span class="n">pt_ii</span><span class="p">,</span> <span class="n">votes_grid_acc</span></div>




<span class="c1"># isolating out just the dynamics</span>
<span class="c1"># can we make this v. fast? ---&gt; it is mainly the advection that is slow....., if we could parallelize in blocks? </span>
<div class="viewcode-block" id="gradient_watershed3D_binary_dynamics">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.watershed.gradient_watershed3D_binary_dynamics">[docs]</a>
<span class="k">def</span> <span class="nf">gradient_watershed3D_binary_dynamics</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> 
                                    <span class="n">gradient_img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">momenta</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
                                    <span class="n">divergence_rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                    <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                    <span class="n">smooth_gradient</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                    <span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                    <span class="n">n_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                    <span class="n">min_area</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                                    <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> 
                                    <span class="n">thresh_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">use_connectivity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                    <span class="n">connectivity_alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                                    <span class="n">debug_viz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">renorm_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; parses the instance level segmentation implicitly given as an input binary or a vector field. </span>
<span class="sd">    The algorithm works as an inverse watershed.</span>
<span class="sd">    </span>
<span class="sd">    Step 1: a grid of points is seeds on the image</span>
<span class="sd">    Step 2: points are propagated for n_iter according to the gradient_img, condensing towards cell centers implicitly implied by the gradient image.</span>
<span class="sd">    Step 3: individual cluster centers are found by binarisation and connected component, removing objects &lt; min_area</span>
<span class="sd">    </span>
<span class="sd">    result is an integer image the same size as binary. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binary : (MxNxL) numpy array</span>
<span class="sd">        input binary image defining the voxels that need labeling</span>
<span class="sd">  	gradient_img :  (MxNxLx3) numpy array</span>
<span class="sd">        This is a gradient field such as that from applying np.array(np.gradient(img)).transpose(1,2,3,0) where img is a potential such as a distance transform or probability map. </span>
<span class="sd">    divergence_rescale : </span>
<span class="sd">        If True, the gradient_img is scaled by the divergence which is equivalent to the mean curvature, this helps to prevent early breakage for tube-like structures.   </span>
<span class="sd">    smooth_sigma : scalar</span>
<span class="sd">        controls the catchment area for identifying distinct cells at the final propagation position. Smaller smooth_sigma leads to more oversegmentation. </span>
<span class="sd">    smooth_gradient : scalar</span>
<span class="sd">    	the isotropic sigma value controlling the Gaussian smoothing of the gradient field. More smoothing results in more cells grouped together</span>
<span class="sd">    delta: scalar</span>
<span class="sd">    	the voxel size to propagate grid points per iteration. Related to the stability. If too small takes too long. If too large, might not converge. if delta=1, takes a 1 voxel step. </span>
<span class="sd">    n_iter: int </span>
<span class="sd">        the number of iterations to run. (To do: monitor convergence and break early to improve speed)</span>
<span class="sd">    min_area: scalar</span>
<span class="sd">        volume of cells &lt; min_area are removed. </span>
<span class="sd">    eps: float</span>
<span class="sd">        a small number for numerical stability</span>
<span class="sd">    thresh_factor: scalar</span>
<span class="sd">        The final cells are identified by thresholding on a threshold mean+thresh_factor*std. Thresh_factor controls what is an object prior to connected components analysis </span>
<span class="sd">    mask: (MxNxL) numpy array</span>
<span class="sd">        optional binary mask to gate the region to parse labels for.</span>
<span class="sd">    debug_viz: bool</span>
<span class="sd">        if True, visualise the position of the points at every algorithm iteration. </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cell_seg_connected_original : (MxNxL)</span>
<span class="sd">        an integer image where each unique int &gt; 0 relates to a unique object such that object 1 is retrieved by cell_seg_connected_original==1.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span> 
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span> 
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="kn">from</span> <span class="nn">.plotting</span> <span class="kn">import</span> <span class="n">set_axes_equal</span>
    
    <span class="k">if</span> <span class="n">gradient_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">gradient_img</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># use the supplied gradients! </span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">binary</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># compute the signed distance transform</span>
        <span class="n">sdf_normals</span><span class="p">,</span> <span class="n">sdf_binary</span> <span class="o">=</span> <span class="n">surf_normal_sdf</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_gradient</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">norm_vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">binary</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">use_connectivity</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.feature_extraction.image</span> <span class="kn">import</span> <span class="n">grid_to_graph</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span> 
        
        <span class="n">W</span> <span class="o">=</span> <span class="n">grid_to_graph</span><span class="p">(</span><span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                        <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                        <span class="n">mask</span><span class="o">=</span><span class="n">binary</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># convert this to laplacian.   </span>
    
        <span class="c1"># create the averaging matrix </span>
        <span class="n">DD</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">DD</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">W</span> <span class="o">=</span> <span class="n">DD</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># averaging</span>
        <span class="k">del</span> <span class="n">DD</span> <span class="c1"># some memory management. </span>
        
        <span class="n">alpha</span><span class="o">=</span><span class="n">connectivity_alpha</span>
        
    <span class="k">if</span> <span class="n">divergence_rescale</span><span class="p">:</span>
        <span class="c1"># rescale the speed</span>
        <span class="n">curvature_3D</span> <span class="o">=</span> <span class="n">mean_curvature_sdf</span><span class="p">(</span><span class="n">sdf_normals</span><span class="p">)</span>
        <span class="n">curvature_3D</span> <span class="o">=</span> <span class="n">_normalize99</span><span class="p">(</span><span class="n">curvature_3D</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">upper</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span> <span class="c1"># rescales to a factor between 0-1</span>
        <span class="n">sdf_normals</span> <span class="o">=</span> <span class="n">sdf_normals</span> <span class="o">*</span> <span class="n">curvature_3D</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1"># multiplicative factor rescaling </span>
    
    <span class="c1"># grid =  np.zeros(binary.shape, dtype=np.int32)</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">binary</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># (N,ndim)</span>
    <span class="c1"># pt_ii = np.argwhere(binary&gt;0).astype(np.float32)</span>
    <span class="n">pt_ii</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># tracks = [pts]</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">momenta</span> <span class="c1"># momentum</span>
    <span class="c1"># g0 = np.zeros(pts.shape)</span>
    <span class="n">g0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">)</span>
    
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        interp helps!. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interp</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_interp3</span><span class="p">(</span><span class="n">pt_ii</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">sdf_normals</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sdf_normals</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&#39;no interp&#39;)</span>
            <span class="c1"># pts_vect_ii = sdf_normals[:,</span>
            <span class="c1">#                           pt_ii[...,0].astype(np.int32), </span>
            <span class="c1">#                           pt_ii[...,1].astype(np.int32), </span>
            <span class="c1">#                           pt_ii[...,2].astype(np.int32)].T  # direct lookup - not interp!. </span>
            <span class="c1"># faster index with flat indices? </span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf_normals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">pt_ii</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sdf_normals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
            
            
        <span class="c1"># renormalize</span>
        <span class="k">if</span> <span class="n">renorm_gradient</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">pts_vect_ii</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts_vect_ii</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update step:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_connectivity</span><span class="p">:</span>
            <span class="n">pts_vect_ii</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">pts_vect_ii</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pts_vect_ii</span><span class="p">)</span> <span class="c1"># twice</span>
            <span class="c1"># pts_vect_ii = alpha * pts_vect_ii + (1-alpha) * np.nanmean(pts_vect_ii[W], axis=1)</span>
            
        <span class="c1"># else:</span>
        <span class="c1"># pt_ii_next = pt_ii + delta*pts_vect_ii</span>
        <span class="n">pt_ii_next</span> <span class="o">=</span> <span class="n">pt_ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span><span class="o">*</span><span class="n">pts_vect_ii</span> <span class="o">+</span> <span class="n">mu</span><span class="o">*</span><span class="n">g0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">delta</span><span class="o">+</span><span class="n">mu</span><span class="p">))</span>  <span class="c1"># add momentum + connectivity. </span>
        <span class="n">g0</span> <span class="o">=</span> <span class="n">pts_vect_ii</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># copy this into the past history.... </span>
        
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># delta_change = np.nanmean(np.linalg.norm(pt_ii_next-pt_ii, axis=-1)) # mean or median?  # this can help with early stopping!. </span>
        <span class="c1"># delta_position_changes.append(delta_change)</span>
        <span class="c1"># print(delta_change)</span>
        
        <span class="c1"># tracks[-1] = pt_ii_next # overwrite </span>
        <span class="n">pt_ii</span> <span class="o">=</span> <span class="n">pt_ii_next</span>
        
        <span class="c1"># plt.figure(figsize=(10,10))</span>
        <span class="c1"># plt.imshow(binary.max(axis=0))</span>
        <span class="c1"># plt.plot(pt_ii_next[:,2], </span>
        <span class="c1">#          pt_ii_next[:,1], &#39;r.&#39;)</span>
        <span class="c1"># plt.show()</span>
        
        <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_proj_type</span><span class="p">(</span><span class="s1">&#39;ortho&#39;</span><span class="p">)</span> <span class="c1"># this works better!.</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_box_aspect</span><span class="p">(</span><span class="n">aspect</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># this works. </span>
            <span class="c1"># ax.scatter(v_watertight[::sampling,0], </span>
            <span class="c1">#             v_watertight[::sampling,1], </span>
            <span class="c1">#             v_watertight[::sampling,2], </span>
            <span class="c1">#             c=&#39;k&#39;, s=1, alpha=0.0)#all_labels_branches[np.squeeze(all_dists)&lt;20], s=1)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pt_ii_next</span><span class="p">[::</span><span class="n">sampling</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                       <span class="n">pt_ii_next</span><span class="p">[::</span><span class="n">sampling</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                       <span class="n">pt_ii_next</span><span class="p">[::</span><span class="n">sampling</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ax.scatter(centroids3D_from_xz[:,0], </span>
            <span class="c1">#            centroids3D_from_xz[:,1],</span>
            <span class="c1">#            centroids3D_from_xz[:,2], c=&#39;g&#39;,s=10)</span>
            <span class="c1"># ax.scatter(centroids3D_from_yz[:,0], </span>
            <span class="c1">#            centroids3D_from_yz[:,1],</span>
            <span class="c1">#            centroids3D_from_yz[:,2], c=&#39;b&#39;,s=10)</span>
            <span class="c1"># # ax.scatter(skel3D_coords[:,0], </span>
            <span class="c1"># #             skel3D_coords[:,1],</span>
            <span class="c1"># #             skel3D_coords[:,2], c=&#39;k&#39;,s=5, alpha=1)</span>
            <span class="c1"># ax.view_init(-90,0)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">180</span><span class="p">)</span>
            <span class="c1"># ax.view_init(180,0)</span>
            <span class="c1"># ax.set_xlim([0,binary.shape[0]]) # why is this plot not good? </span>
            <span class="c1"># ax.set_ylim([0,binary.shape[1]])</span>
            <span class="c1"># ax.set_zlim([0,binary.shape[2]])</span>
            <span class="n">set_axes_equal</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">pt_ii</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># return the initial and final position!. </span></div>












</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Daetwyler Stephan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>