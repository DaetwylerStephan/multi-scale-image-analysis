<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows &mdash; Self-driving, multi-scale image analysis 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Self-driving, multi-scale image analysis
              <img src="../../../../_static/multi_scale_analysis_logo.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started and installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Installation.html">Getting started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Microscope characterization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../PSF_analysis.html">PSF analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ShannonEntropyAnalysis.html">Shannon Entropy Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Low-resolution analysis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Data_stitching.html">Data stitching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../LowRes_Segmentation.html">Low-resolution segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../HopkinsStatistics.html">Hopkins Statistics Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">High-resolution analysis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../HighRes_Segmentation.html">High-resolution segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Cell_ShapeAnalysis.html">Cell Shape Feature Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Cell_CurvatureAnalysis.html">Cell Curvature Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Data_visualization.html">Data visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API references</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">multiScaleAnalysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Self-driving, multi-scale image analysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Wed Feb 15 03:04:09 2023</span>

<span class="sd">@author: fyz11</span>

<span class="sd">Module for computing and implementing various flow definitions. </span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Flow 1 - euclidean distance transform. </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># def distance_transform_labels(labels, bg_label=0):</span>
    
<span class="c1">#     import numpy as np </span>
<span class="c1">#     from scipy.ndimage import distance_transform_edt</span>
<span class="c1">#     # import skfmm</span>
    
<span class="c1">#     dtform = np.zeros(labels.shape)</span>
<span class="c1">#     dtform_flow = np.zeros((2,)+labels.shape) # keep these separate!. </span>
    
<span class="c1">#     uniq_labels = np.setdiff1d(np.unique(labels), bg_label)</span>
    
<span class="c1">#     for lab in uniq_labels:</span>
        
<span class="c1">#         mask = labels == lab</span>
<span class="c1">#         # dist_mask = skfmm.distance(mask&gt;0)</span>
<span class="c1">#         # dist_mask = distance_transform_edt(mask&gt;0)</span>
<span class="c1">#         dist_mask = sdf_distance_transform(mask&gt;0)</span>
        
<span class="c1">#         # compute the gradient!. </span>
<span class="c1">#         grad_dist_mask = np.array(np.gradient(dist_mask))</span>
<span class="c1">#         grad_dist_mask = grad_dist_mask / (np.linalg.norm(grad_dist_mask, axis=0)[None,...] + 1e-20)</span>
        
<span class="c1">#         dtform_flow[:,mask&gt;0] = grad_dist_mask[:,mask&gt;0].copy()</span>
        
<span class="c1">#         dtform[mask&gt;0] = dist_mask[mask&gt;0]</span>
        
<span class="c1">#     return dtform_flow, dtform </span>


<span class="c1"># =============================================================================</span>
<span class="c1">#  Use the euclidean distance transform given in the edt library which is faster.</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="distance_transform_labels_fast">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.distance_transform_labels_fast">[docs]</a>
<span class="k">def</span> <span class="nf">distance_transform_labels_fast</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">sdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">black_border</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; compute euclidean distance transform for each uniquely labelled cell in a 2D/3D binary image </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">edt</span> <span class="c1"># external fast distance transform from seung lab. https://github.com/seung-lab/euclidean-distance-transform-3d # can also compute sdf?</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sdf</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dtform</span> <span class="o">=</span> <span class="n">edt</span><span class="o">.</span><span class="n">edt</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> 
                             <span class="n">black_border</span><span class="o">=</span><span class="n">black_border</span><span class="p">,</span> 
                             <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> 
                             <span class="n">parallel</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>    
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># does this not work for a 3D label set?</span>
            <span class="n">dtform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edt</span><span class="o">.</span><span class="n">edt</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">black_border</span><span class="o">=</span><span class="n">black_border</span><span class="p">,</span> 
                                       <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> 
                                       <span class="n">parallel</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dtform</span> <span class="o">=</span> <span class="n">edt</span><span class="o">.</span><span class="n">sdf</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">black_border</span><span class="o">=</span><span class="n">black_border</span><span class="p">,</span>
                             <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> 
                             <span class="n">parallel</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edt</span><span class="o">.</span><span class="n">sdf</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">black_border</span><span class="o">=</span><span class="n">black_border</span><span class="p">,</span> 
                                       <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> 
                                       <span class="n">parallel</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">dtform</span> </div>




<span class="c1"># =============================================================================</span>
<span class="c1">#   Use the poisson heat distance transform </span>
<span class="c1"># =============================================================================</span>

<span class="c1"># construct the laplacian grid for a 2D image. (might be faster to exploit kron! )</span>
<span class="k">def</span> <span class="nf">_laplacian_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># this is the only working solution! </span>
    
    <span class="kn">import</span> <span class="nn">scipy.sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>
    
    <span class="n">mat_D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">mat_D</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mat_D</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">mat_D</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">mat_A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">block_diag</span><span class="p">([</span><span class="n">mat_D</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>
    
    <span class="n">mat_A</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="n">mat_A</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># find the masked i.e. zeros</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># in (y,x)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_range</span>
        <span class="n">mat_A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mat_A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mat_A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mat_A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">x_range</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mat_A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">x_range</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">mat_A</span> <span class="o">=</span> <span class="n">mat_A</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat_A</span> <span class="o">=</span> <span class="n">mat_A</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">mat_A</span>

<div class="viewcode-block" id="poisson_dist_tform">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.poisson_dist_tform">[docs]</a>
<span class="k">def</span> <span class="nf">poisson_dist_tform</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computation for a single binary image. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># pad with ones.  # ones need for connectivity....</span>
    
    <span class="n">mat_A</span> <span class="o">=</span> <span class="n">_laplacian_matrix</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># this is correct!</span>

    <span class="k">if</span> <span class="n">pt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="n">mask_flat</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>    
        <span class="n">mat_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_flat</span><span class="p">))</span>
        <span class="n">mat_b</span><span class="p">[</span><span class="n">mask_flat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># now we need to zero the padding</span>
        <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">mask</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">mask</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        
        <span class="c1"># solve within the mask!    </span>
        <span class="n">mask_flat</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>    
        <span class="c1"># inside the mask:</span>
        <span class="c1"># \Delta f = div v = \Delta g       </span>
        <span class="n">mat_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_flat</span><span class="p">))</span> <span class="c1"># does this matter -&gt; the amount... </span>
        <span class="n">mat_b</span><span class="p">[</span><span class="n">mask_flat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="c1"># x = spsolve(mat_A, mat_b, use_umfpack=True)  # makes no difference?   </span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">mat_A</span><span class="p">,</span> <span class="n">mat_b</span><span class="p">)</span>    
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="c1"># solution is only positive!.</span>
    <span class="k">return</span> <span class="n">x</span> </div>

    
<div class="viewcode-block" id="poisson_dist_tform_flow">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.poisson_dist_tform_flow">[docs]</a>
<span class="k">def</span> <span class="nf">poisson_dist_tform_flow</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">power_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve diffusion for points. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="n">poisson</span> <span class="o">=</span> <span class="n">poisson_dist_tform</span><span class="p">(</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">centroid</span><span class="p">)</span> <span class="c1"># compute the point source distance transform </span>

    <span class="c1"># if log_dist:</span>
        <span class="c1"># poisson = np.log(poisson+1.)</span>
    <span class="k">if</span> <span class="n">power_dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># why are we getting nan? wiht power boost? </span>
        <span class="c1"># this is to boost beyond the numerical limits. </span>
        <span class="n">poisson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">poisson</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">poisson</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">**</span><span class="n">power_dist</span> <span class="c1"># valid for 0-1</span>
        
    <span class="n">poisson_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">poisson</span><span class="p">))</span>

    <span class="n">dy</span> <span class="o">=</span> <span class="n">poisson_flow</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">poisson_flow</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">poisson</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">dy</span><span class="p">,</span><span class="n">dx</span><span class="p">))</span></div>



<span class="c1"># =============================================================================</span>
<span class="c1">#   Defining the fmm geodesic flow</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># def fmm_point_source2D(binary, pt):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     This is a much better solver of the diffusion</span>
<span class="c1">#     &quot;&quot;&quot;</span>
    
<span class="c1">#     import skfmm</span>
<span class="c1">#     import numpy as np</span>
<span class="c1">#     import skimage.morphology as skmorph</span>
<span class="c1">#     import scipy.ndimage as ndimage </span>
    
<span class="c1">#     # create a masked array</span>
<span class="c1">#     # mask = np.logical_not(skmorph.binary_dilation(binary, skmorph.disk(1)))</span>
<span class="c1">#     mask = np.logical_not(binary).copy()</span>
<span class="c1">#     # mask2 = np.logical_not(skmorph.binary_dilation(binary, skmorph.disk(1)))</span>
<span class="c1">#     mask2 = mask.copy()</span>
<span class="c1">#     m = np.ones_like(binary)</span>
<span class="c1">#     m[pt[0],pt[1]] = 0</span>
<span class="c1">#     m = np.ma.masked_array(m, mask2)</span>

<span class="c1">#     dist_image = skfmm.distance(m)  # this is the answer!!!     </span>
<span class="c1">#     dist_image = dist_image.max()-dist_image # invert the image!. # many ways to do this. </span>
    
<span class="c1">#     # fix up the boundary differentiation. </span>
<span class="c1">#     dist_outer = (skfmm.distance(mask)*-1) # can we make it smoother? # best</span>
<span class="c1">#     dist_image[mask&gt;0] = dist_outer[mask&gt;0] # this seems to work! (it gives a little normal push. ) </span>
<span class="c1">#     # dist_image = dist_image/dist_image.max() # retain this. </span>
    
<span class="c1">#     dist_gradient = np.array(np.gradient(dist_image))</span>
<span class="c1">#     # dist_gradient = dist_gradient/(np.linalg.norm(dist_gradient, axis=0)[None,...]+1e-20) # normalise. </span>
<span class="c1">#     dist_gradient[:,mask&gt;0] = 0</span>
<span class="c1">#     dist_image[mask&gt;0]=0</span>
    
<span class="c1">#     return dist_image, dist_gradient</span>

<div class="viewcode-block" id="fmm_point_source2D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.fmm_point_source2D">[docs]</a>
<span class="k">def</span> <span class="nf">fmm_point_source2D</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a much better solver of the diffusion</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">import</span> <span class="nn">skfmm</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span> 
    
    <span class="c1"># construct the binary </span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">binary</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># construct the masked out region!. </span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># mask2 = np.logical_not(skmorph.binary_dilation(binary, skmorph.disk(1)))</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
    <span class="n">m</span><span class="p">[</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># define the point source!. </span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>

    <span class="n">dist_image</span> <span class="o">=</span> <span class="n">skfmm</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>  <span class="c1"># this is the answer!!!     </span>
    <span class="n">dist_image</span> <span class="o">=</span> <span class="n">dist_image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">dist_image</span> <span class="c1"># invert the image!. # many ways to do this. </span>
    
    <span class="c1"># fix up the boundary differentiation. </span>
    <span class="n">dist_outer</span> <span class="o">=</span> <span class="p">(</span><span class="n">skfmm</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># can we make it smoother? # best</span>
    <span class="n">dist_image</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_outer</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># this seems to work! (it gives a little normal push. ) </span>
    <span class="c1"># dist_image = dist_image/dist_image.max() # retain this. </span>
    
    <span class="n">dist_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">dist_image</span><span class="p">))</span>
    
    <span class="n">dy</span> <span class="o">=</span> <span class="n">dist_gradient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dist_gradient</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">dist_image</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">dy</span><span class="p">,</span><span class="n">dx</span><span class="p">))</span></div>

    
   
<span class="c1"># =============================================================================</span>
<span class="c1">#   Replicating cellpose flow</span>
<span class="c1"># =============================================================================</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">int32</span><span class="p">,</span> <span class="n">vectorize</span>
<span class="nd">@njit</span><span class="p">(</span><span class="s1">&#39;(float64[:], int32[:], int32[:], int32, int32, int32, int32)&#39;</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_extend_centers</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">ymed</span><span class="p">,</span><span class="n">xmed</span><span class="p">,</span><span class="n">Lx</span><span class="p">,</span> <span class="n">niter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; run diffusion from center of mask (ymed, xmed) on mask pixels (y, x)</span>
<span class="sd">    </span>
<span class="sd">    taken from  cellpose source code.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------</span>
<span class="sd">    T: float64, array</span>
<span class="sd">        _ x Lx array that diffusion is run in</span>
<span class="sd">    y: int32, array</span>
<span class="sd">        pixels in y inside mask</span>
<span class="sd">    x: int32, array</span>
<span class="sd">        pixels in x inside mask</span>
<span class="sd">    ymed: int32</span>
<span class="sd">        center of mask in y</span>
<span class="sd">    xmed: int32</span>
<span class="sd">        center of mask in x</span>
<span class="sd">    Lx: int32</span>
<span class="sd">        size of x-dimension of masks</span>
<span class="sd">    niter: int32</span>
<span class="sd">        number of iterations to run diffusion</span>
<span class="sd">    Returns</span>
<span class="sd">    ---------------</span>
<span class="sd">    T: float64, array</span>
<span class="sd">        amount of diffused particles at each pixel</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">T</span><span class="p">[</span><span class="n">ymed</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">xmed</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mf">9.</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>   <span class="o">+</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span>
                                            <span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>     <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                            <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                            <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">T</span>


<div class="viewcode-block" id="cellpose_diffuse2D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.cellpose_diffuse2D">[docs]</a>
<span class="k">def</span> <span class="nf">cellpose_diffuse2D</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">niter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve diffusion for points. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">ly</span><span class="p">,</span> <span class="n">lx</span> <span class="o">=</span> <span class="n">shape</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># these are the diffusion points to solve for. </span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ly</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">lx</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">_extend_centers</span><span class="p">(</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                        <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                        <span class="n">ymed</span><span class="o">=</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                        <span class="n">xmed</span><span class="o">=</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                        <span class="n">Lx</span><span class="o">=</span><span class="n">int32</span><span class="p">(</span><span class="n">lx</span><span class="p">),</span> 
                        <span class="n">niter</span><span class="o">=</span><span class="n">int32</span><span class="p">(</span><span class="n">niter</span><span class="p">))</span>
    <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">T</span><span class="p">[(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">lx</span> <span class="o">+</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">dy</span><span class="p">,</span><span class="n">dx</span><span class="p">))</span></div>



<span class="c1"># =============================================================================</span>
<span class="c1">#   Generic wrapper functions.  </span>
<span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="distance_tform_labels2D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.distance_tform_labels2D">[docs]</a>
<span class="k">def</span> <span class="nf">distance_tform_labels2D</span><span class="p">(</span><span class="n">labelled</span><span class="p">,</span> <span class="n">dtform_fnc</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    this function wraps a distance transform defined for a single binary and generalize to multi-labels. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">labelled</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">labelled</span><span class="o">&gt;</span><span class="mi">0</span>
    
    <span class="n">labelled_regions</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">labelled</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">labelled_regions</span><span class="p">:</span>
        
        <span class="n">patch</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">image</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">bbox</span> <span class="c1"># (min_row, min_col, max_row, max_col)</span>
        <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">box</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">coords</span>
        
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dtform_fnc</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span> 
        
        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">dist</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        
        <span class="c1"># copy it into the larger array. </span>
        <span class="n">distance</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y1</span><span class="p">,</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">distance</span></div>



<div class="viewcode-block" id="distance_centroid_tform_flow_labels2D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.distance_centroid_tform_flow_labels2D">[docs]</a>
<span class="k">def</span> <span class="nf">distance_centroid_tform_flow_labels2D</span><span class="p">(</span><span class="n">labelled</span><span class="p">,</span> <span class="n">dtform_method</span><span class="o">=</span><span class="s1">&#39;cellpose&#39;</span><span class="p">,</span> <span class="n">guide_img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">iter_factor</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">power_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function wraps a distance transform defined for a single binary with point source and generalize to multi-labels. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># is there a better way to smooth this? </span>
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span>
    <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">skeletonize</span>
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">labelled</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,)</span><span class="o">+</span><span class="n">labelled</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># binary = labelled&gt;0 # to tell us which is not background </span>
    
    <span class="n">labelled_regions</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">labelled</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">labelled_regions</span><span class="p">:</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">image</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">bbox</span> <span class="c1"># (min_row, min_col, max_row, max_col) # same behavior</span>
        <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">box</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y1</span><span class="p">,</span><span class="n">x1</span><span class="p">])</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">coords</span> 
        
        <span class="c1"># determine the median </span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        stability for gauss-siedel methods. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">sksegmentation</span><span class="o">.</span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">patch</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">inner</span><span class="p">))</span>
        <span class="n">inner_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">inner</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner_coords</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">inner_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_coords</span><span class="o">+</span><span class="n">start</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">guide_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># # use this to find an internal fixed point. </span>
            <span class="n">coords_guide</span> <span class="o">=</span> <span class="n">guide_img</span><span class="p">[</span><span class="n">inner_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">inner_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">coords_valid</span> <span class="o">=</span> <span class="n">inner_coords</span><span class="p">[</span><span class="n">coords_guide</span><span class="o">&gt;=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">coords_guide</span><span class="p">,</span> <span class="n">fixed_point_percentile</span><span class="o">*</span><span class="mi">100</span><span class="p">)]</span>
            <span class="c1"># coords_valid = np.argwhere(skeletonize(patch&gt;0)&gt;0)+start[None,:]</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">coords_valid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords_valid</span><span class="o">-</span><span class="n">centroid</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">inner_coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">inner_coords</span><span class="o">-</span><span class="n">centroid</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))]</span>
            
            
        <span class="k">if</span> <span class="n">dtform_method</span> <span class="o">==</span> <span class="s1">&#39;cellpose&#39;</span><span class="p">:</span>
            <span class="n">niter</span> <span class="o">=</span> <span class="n">iter_factor</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># there should be a better estimate of this. </span>
            
            <span class="n">dist_</span><span class="p">,</span> <span class="n">flow_</span> <span class="o">=</span> <span class="n">cellpose_diffuse2D</span><span class="p">(</span><span class="n">coords</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># remove the global offset. </span>
                                           <span class="n">centroid</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> 
                                            <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">dtform_method</span> <span class="o">==</span> <span class="s1">&#39;cellpose_improve&#39;</span><span class="p">:</span>    
            <span class="n">dist_</span><span class="p">,</span> <span class="n">flow_</span> <span class="o">=</span> <span class="n">poisson_dist_tform_flow</span><span class="p">(</span><span class="n">coords</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># remove the global offset. </span>
                                                   <span class="n">centroid</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                                   <span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                                   <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">dtform_method</span> <span class="o">==</span> <span class="s1">&#39;fmm&#39;</span><span class="p">:</span>  
            <span class="c1"># geodesic fast marching method</span>
            <span class="n">dist_</span><span class="p">,</span> <span class="n">flow_</span> <span class="o">=</span> <span class="n">fmm_point_source2D</span><span class="p">(</span><span class="n">coords</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># remove the global offset. </span>
                                                   <span class="n">centroid</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                                   <span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">patch</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        
        <span class="c1"># diffuse_out = out.reshape(ly+2,lx+2, order=&#39;&#39;)</span>
        <span class="n">distance</span><span class="p">[</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dist_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">flow</span><span class="p">[:,</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">flow_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="c1"># normalise</span>
    <span class="n">flow</span> <span class="o">/=</span> <span class="p">(</span><span class="mf">1e-20</span> <span class="o">+</span> <span class="p">(</span><span class="n">flow</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">distance</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">flow</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># concatenate this!.  # then we compute both!. </span></div>



<span class="c1"># =============================================================================</span>
<span class="c1"># Parallel scripts</span>
<span class="c1"># =============================================================================</span>

<span class="k">def</span> <span class="nf">_distance_centroid_tform_flow_labels2D_chunk</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">,</span> 
                                                 <span class="n">dtform_method</span><span class="o">=</span><span class="s1">&#39;cellpose&#39;</span><span class="p">,</span> 
                                                 <span class="n">guide_img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                 <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                                                 <span class="n">iter_factor</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                                 <span class="n">power_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

     <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

     <span class="k">if</span> <span class="n">guide_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">dtform_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_centroid_tform_flow_labels2D</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="n">zz</span><span class="p">],</span> 
                                                                       <span class="n">dtform_method</span> <span class="o">=</span> <span class="n">dtform_method</span><span class="p">,</span>
                                                                       <span class="n">guide_img</span><span class="o">=</span><span class="n">guide_img</span><span class="p">[</span><span class="n">zz</span><span class="p">],</span> 
                                                                       <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span>
                                                                       <span class="n">iter_factor</span><span class="o">=</span><span class="n">iter_factor</span><span class="p">,</span>
                                                                       <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">)</span> <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">))])</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="n">dtform_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_centroid_tform_flow_labels2D</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="n">zz</span><span class="p">],</span> 
                                                                       <span class="n">dtform_method</span> <span class="o">=</span> <span class="n">dtform_method</span><span class="p">,</span>
                                                                       <span class="n">guide_img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                                                       <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span>
                                                                       <span class="n">iter_factor</span><span class="o">=</span><span class="n">iter_factor</span><span class="p">,</span>
                                                                       <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">)</span> <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">))])</span>
     <span class="k">return</span> <span class="n">dtform_flow</span>
 
    
<div class="viewcode-block" id="distance_centroid_tform_flow_labels2D_parallel">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.distance_centroid_tform_flow_labels2D_parallel">[docs]</a>
<span class="k">def</span> <span class="nf">distance_centroid_tform_flow_labels2D_parallel</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">,</span> 
                                                   <span class="n">dtform_method</span><span class="o">=</span><span class="s1">&#39;cellpose&#39;</span><span class="p">,</span>
                                                    <span class="n">guide_image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                    <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                                                    <span class="n">iter_factor</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                                                    <span class="n">n_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                                    <span class="n">power_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">n_proc</span> <span class="o">=</span> <span class="n">n_processes</span>
    <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">)</span><span class="o">//</span><span class="n">n_proc</span>
    
    <span class="c1"># chunk the data. </span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i_proc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc</span><span class="p">):</span>
        <span class="n">chunkstart</span> <span class="o">=</span> <span class="n">i_proc</span> <span class="o">*</span> <span class="n">chunksize</span>
        <span class="c1"># make sure to include the division remainder for the last process</span>
        <span class="n">chunkend</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_proc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunksize</span> <span class="k">if</span> <span class="n">i_proc</span> <span class="o">&lt;</span> <span class="n">n_proc</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">chunkstart</span><span class="p">,</span> <span class="n">chunkend</span><span class="p">)])</span>
 
    <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">chunks</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">)</span>
         
    <span class="c1"># parallel computing </span>
    <span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">n_proc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1"># starts the sub-processes without blocking</span>
        <span class="c1"># pass the chunk to each worker process</span>
        <span class="c1"># proc_results = [pool.apply_async(centroid_geodesic_distance_transform2D_chunk,</span>
        <span class="c1">#                                    args=(chunk,))</span>
        <span class="c1">#                                  for chunk in chunks]</span>
        <span class="k">if</span> <span class="n">dtform_method</span> <span class="o">==</span> <span class="s1">&#39;cellpose_improve&#39;</span><span class="p">:</span>
            <span class="n">proc_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_distance_centroid_tform_flow_labels2D_chunk</span><span class="p">,</span>
                                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">dtform_method</span><span class="p">,</span> <span class="n">guide_image</span><span class="p">,</span><span class="n">fixed_point_percentile</span><span class="p">,</span> <span class="n">power_dist</span><span class="p">))</span>
                                             <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_distance_centroid_tform_flow_labels2D_chunk</span><span class="p">,</span>
                                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">dtform_method</span><span class="p">,</span> <span class="n">guide_image</span><span class="p">,</span><span class="n">fixed_point_percentile</span><span class="p">,</span> <span class="n">iter_factor</span><span class="p">))</span>
                                             <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>
         
        <span class="c1"># blocks until all results are fetched</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">proc_results</span><span class="p">])</span>
         
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="distance_centroid_tform_flow_labels2D_dask">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.distance_centroid_tform_flow_labels2D_dask">[docs]</a>
<span class="k">def</span> <span class="nf">distance_centroid_tform_flow_labels2D_dask</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">,</span> 
                                                   <span class="n">dtform_method</span><span class="o">=</span><span class="s1">&#39;cellpose&#39;</span><span class="p">,</span>
                                                    <span class="n">guide_image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                    <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                                                    <span class="n">iter_factor</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                                                    <span class="n">n_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                                    <span class="n">power_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># import multiprocessing as mp</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">dask</span>
    <span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
    
    <span class="n">n_proc</span> <span class="o">=</span> <span class="n">n_processes</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">n_proc</span><span class="p">)</span>
    
    <span class="n">lazy_flow</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">distance_centroid_tform_flow_labels2D</span><span class="p">)</span>
    
    
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sli</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">dtform_method</span> <span class="o">==</span> <span class="s1">&#39;cellpose_improve&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lazy_flow</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="n">sli</span><span class="p">],</span> 
                                     <span class="n">dtform_method</span><span class="o">=</span><span class="n">dtform_method</span><span class="p">,</span> 
                                     <span class="n">guide_img</span><span class="o">=</span><span class="n">guide_image</span><span class="p">[</span><span class="n">sli</span><span class="p">],</span> 
                                     <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span>
                                     <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lazy_flow</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="n">sli</span><span class="p">],</span> 
                                     <span class="n">dtform_method</span><span class="o">=</span><span class="n">dtform_method</span><span class="p">,</span> 
                                     <span class="n">guide_img</span><span class="o">=</span><span class="n">guide_image</span><span class="p">[</span><span class="n">sli</span><span class="p">],</span> 
                                     <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span>
                                     <span class="n">iter_factor</span><span class="o">=</span><span class="n">iter_factor</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
         
    <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">res</span></div>



<span class="c1"># parallel above but for dtforms</span>
<span class="k">def</span> <span class="nf">_distance_tform_labels2D_chunk</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">,</span> 
                                    <span class="n">dtform_fnc</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

     <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
     
     <span class="n">dtform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_tform_labels2D</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="n">zz</span><span class="p">],</span> 
                                                <span class="n">dtform_fnc</span> <span class="o">=</span> <span class="n">dtform_fnc</span><span class="p">,</span>
                                                <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">)</span> <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">))])</span>
     
     <span class="k">return</span> <span class="n">dtform</span>
 
    
<div class="viewcode-block" id="distance_tform_labels2D_parallel">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.distance_tform_labels2D_parallel">[docs]</a>
<span class="k">def</span> <span class="nf">distance_tform_labels2D_parallel</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">,</span> 
                                     <span class="n">dtform_fnc</span><span class="p">,</span>
                                     <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                     <span class="n">n_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">n_proc</span> <span class="o">=</span> <span class="n">n_processes</span>
    <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">)</span><span class="o">//</span><span class="n">n_proc</span>
    
    <span class="c1"># chunk the data. </span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i_proc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc</span><span class="p">):</span>
        <span class="n">chunkstart</span> <span class="o">=</span> <span class="n">i_proc</span> <span class="o">*</span> <span class="n">chunksize</span>
        <span class="c1"># make sure to include the division remainder for the last process</span>
        <span class="n">chunkend</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_proc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunksize</span> <span class="k">if</span> <span class="n">i_proc</span> <span class="o">&lt;</span> <span class="n">n_proc</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">chunkstart</span><span class="p">,</span> <span class="n">chunkend</span><span class="p">)])</span>
 
    <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">chunks</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">labelled_array</span><span class="p">)</span>
         
    <span class="c1"># parallel computing </span>
    <span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">n_proc</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1"># starts the sub-processes without blocking</span>
        <span class="n">proc_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_distance_tform_labels2D_chunk</span><span class="p">,</span>
                                           <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">dtform_fnc</span><span class="p">,</span> <span class="n">clip</span><span class="p">))</span>
                                         <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>
       
        <span class="c1"># blocks until all results are fetched</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">proc_results</span><span class="p">])</span>
         
    <span class="k">return</span> <span class="n">res</span></div>




<span class="k">def</span> <span class="nf">_relabel_slices</span><span class="p">(</span><span class="n">labelled</span><span class="p">,</span> <span class="n">bg_label</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">max_ID</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">labelled_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labelled</span><span class="p">:</span>
        <span class="n">lab_</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># make a copy! </span>
        <span class="n">lab_</span><span class="p">[</span><span class="n">lab</span><span class="o">&gt;</span><span class="n">bg_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span><span class="p">[</span><span class="n">lab</span><span class="o">&gt;</span><span class="n">bg_label</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_ID</span> <span class="c1"># only update the foreground! </span>
        <span class="n">labelled_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_ID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        
    <span class="n">labelled_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labelled_</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">labelled_</span>


<div class="viewcode-block" id="remove_bad_flow_masks_3D">
<a class="viewcode-back" href="../../../../multiScaleAnalysis.SegmentationHighres.gradient_watershed.html#multiScaleAnalysis.SegmentationHighres.gradient_watershed.flows.remove_bad_flow_masks_3D">[docs]</a>
<span class="k">def</span> <span class="nf">remove_bad_flow_masks_3D</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> 
                             <span class="n">flow</span><span class="p">,</span> 
                             <span class="n">flow_threshold</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                             <span class="n">dtform_method</span><span class="o">=</span><span class="s1">&#39;cellpose_improve&#39;</span><span class="p">,</span>  
                             <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> 
                             <span class="n">n_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                             <span class="n">power_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                             <span class="n">filter_scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
    <span class="kn">from</span> <span class="nn">.filters</span> <span class="kn">import</span> <span class="n">var_combine</span>

    <span class="k">if</span> <span class="n">flow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: input ref flow is not same size as predicted masks&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># maybe don&#39;t need? </span>
    <span class="n">label_xy</span> <span class="o">=</span> <span class="n">_relabel_slices</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">label_xz</span> <span class="o">=</span> <span class="n">_relabel_slices</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">label_yz</span> <span class="o">=</span> <span class="n">_relabel_slices</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">label_xy</span><span class="p">[</span><span class="mi">100</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">label_xz</span><span class="p">[</span><span class="n">label_xz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dtform_method</span><span class="o">==</span><span class="s1">&#39;cellpose&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: not yet implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;starting xy&#39;</span><span class="p">)</span>
        <span class="n">guide_image_xy</span> <span class="o">=</span> <span class="n">distance_transform_labels_fast</span><span class="p">(</span><span class="n">label_xy</span><span class="p">)</span>
        <span class="n">mask_xy_gradient</span> <span class="o">=</span> <span class="n">distance_centroid_tform_flow_labels2D_parallel</span><span class="p">(</span><span class="n">label_xy</span><span class="p">,</span> 
                                                                                  <span class="n">dtform_method</span><span class="o">=</span><span class="n">dtform_method</span><span class="p">,</span>
                                                                                  <span class="n">guide_image</span><span class="o">=</span><span class="n">guide_image_xy</span><span class="p">,</span>
                                                                                  <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span> 
                                                                                  <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
                                                                                  <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">)</span>
        <span class="c1"># mask_xy_gradient = distance_centroid_tform_flow_labels2D_dask(label_xy, </span>
        <span class="c1">#                                                                 dtform_method=dtform_method,</span>
        <span class="c1">#                                                                 guide_image=guide_image_xy,</span>
        <span class="c1">#                                                                 fixed_point_percentile=fixed_point_percentile, </span>
        <span class="c1">#                                                                 n_processes=n_processes,</span>
        <span class="c1">#                                                                 power_dist=power_dist)</span>
        <span class="n">mask_xy_gradient</span> <span class="o">=</span> <span class="n">mask_xy_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mask_xy_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask_xy_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">mask_xy_gradient</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask_xy_gradient</span> <span class="o">=</span> <span class="n">mask_xy_gradient</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># we must flip the channels!. </span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done xy &#39;</span><span class="p">)</span>
        <span class="n">guide_image_xz</span> <span class="o">=</span> <span class="n">distance_transform_labels_fast</span><span class="p">(</span><span class="n">label_xz</span><span class="p">)</span>
        <span class="n">mask_xz_gradient</span> <span class="o">=</span> <span class="n">distance_centroid_tform_flow_labels2D_parallel</span><span class="p">(</span><span class="n">label_xz</span><span class="p">,</span> 
                                                                                <span class="n">dtform_method</span><span class="o">=</span><span class="n">dtform_method</span><span class="p">,</span>
                                                                                  <span class="n">guide_image</span><span class="o">=</span><span class="n">guide_image_xz</span><span class="p">,</span>
                                                                                  <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span> 
                                                                                  <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
                                                                                  <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">)</span>
        <span class="c1"># mask_xz_gradient = distance_centroid_tform_flow_labels2D_dask(label_xz, </span>
        <span class="c1">#                                                                 dtform_method=dtform_method,</span>
        <span class="c1">#                                                                   guide_image=guide_image_xz,</span>
        <span class="c1">#                                                                   fixed_point_percentile=fixed_point_percentile, </span>
        <span class="c1">#                                                                   n_processes=n_processes,</span>
        <span class="c1">#                                                                   power_dist=power_dist)</span>
        <span class="n">mask_xz_gradient</span> <span class="o">=</span> <span class="n">mask_xz_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mask_xz_gradient</span> <span class="o">=</span> <span class="n">mask_xz_gradient</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span> <span class="p">)</span>
        <span class="n">mask_xz_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask_xz_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">mask_xz_gradient</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask_xz_gradient</span> <span class="o">=</span> <span class="n">mask_xz_gradient</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># we must flip the channels!. </span>
        
        <span class="n">guide_image_yz</span> <span class="o">=</span> <span class="n">distance_transform_labels_fast</span><span class="p">(</span><span class="n">label_yz</span><span class="p">)</span>
        <span class="n">mask_yz_gradient</span> <span class="o">=</span> <span class="n">distance_centroid_tform_flow_labels2D_parallel</span><span class="p">(</span><span class="n">label_yz</span><span class="p">,</span> 
                                                                                <span class="n">dtform_method</span><span class="o">=</span><span class="n">dtform_method</span><span class="p">,</span>
                                                                                  <span class="n">guide_image</span><span class="o">=</span><span class="n">guide_image_yz</span><span class="p">,</span>
                                                                                  <span class="n">fixed_point_percentile</span><span class="o">=</span><span class="n">fixed_point_percentile</span><span class="p">,</span> 
                                                                                  <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
                                                                                  <span class="n">power_dist</span><span class="o">=</span><span class="n">power_dist</span><span class="p">)</span>
        <span class="c1"># mask_yz_gradient = distance_centroid_tform_flow_labels2D_dask(label_yz, </span>
        <span class="c1">#                                                                 dtform_method=dtform_method,</span>
        <span class="c1">#                                                                   guide_image=guide_image_yz,</span>
        <span class="c1">#                                                                   fixed_point_percentile=fixed_point_percentile, </span>
        <span class="c1">#                                                                   n_processes=n_processes,</span>
        <span class="c1">#                                                                   power_dist=power_dist)</span>
        <span class="n">mask_yz_gradient</span> <span class="o">=</span> <span class="n">mask_yz_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mask_yz_gradient</span> <span class="o">=</span> <span class="n">mask_yz_gradient</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> 
        <span class="n">mask_yz_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask_yz_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">mask_yz_gradient</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">mask_yz_gradient</span> <span class="o">=</span> <span class="n">mask_yz_gradient</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># we must flip the channels!. </span>
        
    
        <span class="n">dx</span> <span class="o">=</span> <span class="n">var_combine</span><span class="p">([</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">mask_xy_gradient</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> 
                                        <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">mask_xz_gradient</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                                      <span class="n">ksize</span><span class="o">=</span><span class="n">filter_scale</span><span class="p">,</span>
                                      <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">var_combine</span><span class="p">([</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">mask_xy_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> 
                                        <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">mask_yz_gradient</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                                      <span class="n">ksize</span><span class="o">=</span><span class="n">filter_scale</span><span class="p">,</span> <span class="c1"># we probably need to tune this up! for this imaging </span>
                                      <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">var_combine</span><span class="p">([</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">mask_xz_gradient</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> 
                                        <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">mask_yz_gradient</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                                      <span class="n">ksize</span><span class="o">=</span><span class="n">filter_scale</span><span class="p">,</span>
                                      <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        
        <span class="n">labels_gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span> <span class="n">dz</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                                            <span class="n">dy</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                                            <span class="n">dx</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># do a little filtering. </span>
        <span class="n">labels_gradients</span> <span class="o">=</span> <span class="n">labels_gradients</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">labels_gradients</span> <span class="o">=</span> <span class="n">labels_gradients</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">labels_gradients</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-20</span><span class="p">)</span> <span class="c1"># do a renormalize!. </span>


    <span class="n">flow_errors</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">labels_gradients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="c1"># over the 3 dimensions.</span>
        <span class="n">flow_errors</span> <span class="o">+=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">labels_gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                                    <span class="n">mask</span><span class="p">,</span>
                                    <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">flow_errors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">flow_errors</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># zero out any nan entries!. </span>
        
    <span class="c1"># 0.6 is the most stringent </span>
    <span class="n">error_labels</span> <span class="o">=</span> <span class="n">flow_errors</span> <span class="o">&gt;</span> <span class="n">flow_threshold</span> <span class="c1"># ok this is quite essential postprocessing! and removes the lion&#39;s share of ill-formed masks at the borders!. </span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">error_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">reg_error_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="n">error_labels</span><span class="p">]</span> <span class="c1"># these are the labels to remove!. </span>
        
        <span class="c1"># set these regions to 0. </span>
        <span class="n">mask_new</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">reg_error_labels</span><span class="p">:</span>
            <span class="n">mask_new</span><span class="p">[</span><span class="n">mask</span><span class="o">==</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">mask_new</span><span class="p">,</span> <span class="n">flow_errors</span><span class="p">,</span> <span class="n">labels_gradients</span> <span class="c1"># return out the intermediate information!. </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">flow_errors</span><span class="p">,</span> <span class="n">labels_gradients</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Daetwyler Stephan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>